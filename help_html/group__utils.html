<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>My Project: Utilities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Utilities</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtr__list.html">tr_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple list structure similar to glib's GList  <a href="structtr__list.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtr__ptrArray.html">tr_ptrArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple pointer array that resizes itself dynamically.  <a href="structtr__ptrArray.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtr__option.html">tr_option</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga66ade85fcf8b5490775d7fc48dffb173"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga66ade85fcf8b5490775d7fc48dffb173"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TR_PTR_ARRAY_INIT_STATIC</b>&#160;&#160;&#160;{ NULL, 0, 0 }</td></tr>
<tr class="separator:ga66ade85fcf8b5490775d7fc48dffb173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddf5ec070e9499d36b7f2009ce736076"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaddf5ec070e9499d36b7f2009ce736076"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UNUSED</b></td></tr>
<tr class="separator:gaddf5ec070e9499d36b7f2009ce736076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec91dc08c5bc333ec658eb887367e9ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaec91dc08c5bc333ec658eb887367e9ed"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TR_GNUC_PRINTF</b>(fmt, args)</td></tr>
<tr class="separator:gaec91dc08c5bc333ec658eb887367e9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09033fd4dda2c3274168f001a1875c31"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga09033fd4dda2c3274168f001a1875c31"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TR_GNUC_NONNULL</b>(...)</td></tr>
<tr class="separator:ga09033fd4dda2c3274168f001a1875c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9483c4bfba8efc71ef4aa0edca92d3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad9483c4bfba8efc71ef4aa0edca92d3d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TR_GNUC_NULL_TERMINATED</b></td></tr>
<tr class="separator:gad9483c4bfba8efc71ef4aa0edca92d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf65532c9fa8fe4cad58a81340fb72ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaf65532c9fa8fe4cad58a81340fb72ca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TR_GNUC_HOT</b></td></tr>
<tr class="separator:gaaf65532c9fa8fe4cad58a81340fb72ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d44cd6237af27d24b3f5f45c0974d51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4d44cd6237af27d24b3f5f45c0974d51"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TR_GNUC_MALLOC</b></td></tr>
<tr class="separator:ga4d44cd6237af27d24b3f5f45c0974d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga479d658dfd60fe8d9709ec67a58b34ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga479d658dfd60fe8d9709ec67a58b34ca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_</b>(a)&#160;&#160;&#160;(a)</td></tr>
<tr class="separator:ga479d658dfd60fe8d9709ec67a58b34ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa99ec4acc4ecb2dc3c2d05da15d0e3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafa99ec4acc4ecb2dc3c2d05da15d0e3f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX</b>(a, b)&#160;&#160;&#160;((a) &gt; (b) ? (a) : (b))</td></tr>
<tr class="separator:gafa99ec4acc4ecb2dc3c2d05da15d0e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3acffbd305ee72dcd4593c0d8af64a4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3acffbd305ee72dcd4593c0d8af64a4f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIN</b>(a, b)&#160;&#160;&#160;((a) &gt; (b) ? (b) : (a))</td></tr>
<tr class="separator:ga3acffbd305ee72dcd4593c0d8af64a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabb85b1446c17ae40e428f514c35c70d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaabb85b1446c17ae40e428f514c35c70d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>tr_new</b>(struct_type, n_structs)&#160;&#160;&#160;((struct_type *) <a class="el" href="group__utils.html#gaecbf1a6df2e4c1e5a6ae39fb063d6871">tr_malloc</a> (sizeof (struct_type) * ((size_t)(n_structs))))</td></tr>
<tr class="separator:gaabb85b1446c17ae40e428f514c35c70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25f77833201e334d80d337aa629a2572"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga25f77833201e334d80d337aa629a2572"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>tr_new0</b>(struct_type, n_structs)&#160;&#160;&#160;((struct_type *) <a class="el" href="group__utils.html#ga4958bd86048009cb5bc24baa46626043">tr_malloc0</a> (sizeof (struct_type) * ((size_t)(n_structs))))</td></tr>
<tr class="separator:ga25f77833201e334d80d337aa629a2572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe667f717d1abd63ec90a352bcb2d96e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafe667f717d1abd63ec90a352bcb2d96e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>tr_renew</b>(struct_type, mem, n_structs)&#160;&#160;&#160;((struct_type *) realloc ((mem), sizeof (struct_type) * ((size_t)(n_structs))))</td></tr>
<tr class="separator:gafe667f717d1abd63ec90a352bcb2d96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga014e085a797444ca1a58b7d12aec185f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga014e085a797444ca1a58b7d12aec185f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TR_PATH_MAX</b>&#160;&#160;&#160;4096</td></tr>
<tr class="separator:ga014e085a797444ca1a58b7d12aec185f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf1f366b692c13018d49a91148b8ad0b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf1f366b692c13018d49a91148b8ad0b8"></a>
typedef struct <a class="el" href="structtr__list.html">tr_list</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gaf1f366b692c13018d49a91148b8ad0b8">tr_list</a></td></tr>
<tr class="memdesc:gaf1f366b692c13018d49a91148b8ad0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple list structure similar to glib's GList <br/></td></tr>
<tr class="separator:gaf1f366b692c13018d49a91148b8ad0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5368aefd1434163cc5d0a3178b35d601"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5368aefd1434163cc5d0a3178b35d601"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>TrListCompareFunc</b> )(const void *a, const void *b)</td></tr>
<tr class="separator:ga5368aefd1434163cc5d0a3178b35d601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25f6a1ced84289e87e28f9149185532c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga25f6a1ced84289e87e28f9149185532c"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>TrListForeachFunc</b> )(void *)</td></tr>
<tr class="separator:ga25f6a1ced84289e87e28f9149185532c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e655cea23609025fa84ed4acc1d892e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6e655cea23609025fa84ed4acc1d892e"></a>
typedef struct <a class="el" href="structtr__thread.html">tr_thread</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tr_thread</b></td></tr>
<tr class="separator:ga6e655cea23609025fa84ed4acc1d892e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeaacc6d9c1baaaaa7991edd4b0ce898"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeeaacc6d9c1baaaaa7991edd4b0ce898"></a>
typedef struct <a class="el" href="structtr__lock.html">tr_lock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tr_lock</b></td></tr>
<tr class="separator:gaeeaacc6d9c1baaaaa7991edd4b0ce898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0380bb53c15be72c73dd37762be49096"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0380bb53c15be72c73dd37762be49096"></a>
typedef struct <a class="el" href="structtr__ptrArray.html">tr_ptrArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga0380bb53c15be72c73dd37762be49096">tr_ptrArray</a></td></tr>
<tr class="memdesc:ga0380bb53c15be72c73dd37762be49096"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple pointer array that resizes itself dynamically. <br/></td></tr>
<tr class="separator:ga0380bb53c15be72c73dd37762be49096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf2da05ff5b22c912cc42c5f1c0d6896"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacf2da05ff5b22c912cc42c5f1c0d6896"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>PtrArrayCompareFunc</b> )(const void *a, const void *b)</td></tr>
<tr class="separator:gacf2da05ff5b22c912cc42c5f1c0d6896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00602c07648d2be545e15064342c4b0c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga00602c07648d2be545e15064342c4b0c"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>PtrArrayForeachFunc</b> )(void *)</td></tr>
<tr class="separator:ga00602c07648d2be545e15064342c4b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3aad1f39759658fe25d999965fa2e05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa3aad1f39759658fe25d999965fa2e05"></a>
typedef struct <a class="el" href="structtr__option.html">tr_option</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tr_option</b></td></tr>
<tr class="separator:gaa3aad1f39759658fe25d999965fa2e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga96a58e29e8dbf2b5bdeb775cba46556e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>TR_OPT_DONE</b> = 0, 
<b>TR_OPT_ERR</b> = -1, 
<b>TR_OPT_UNK</b> = -2
 }</td></tr>
<tr class="separator:ga96a58e29e8dbf2b5bdeb775cba46556e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae12f413b8dd767fe7a2a314a04e77e89"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae12f413b8dd767fe7a2a314a04e77e89"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gae12f413b8dd767fe7a2a314a04e77e89">tr_clientForId</a> (char *buf, size_t buflen, const void *peer_id)</td></tr>
<tr class="memdesc:gae12f413b8dd767fe7a2a314a04e77e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">parse a peer-id into a human-readable client name and version number <br/></td></tr>
<tr class="separator:gae12f413b8dd767fe7a2a314a04e77e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26daf1210383c7036369bac7848c77df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga26daf1210383c7036369bac7848c77df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga26daf1210383c7036369bac7848c77df">tr_sha1</a> (uint8_t *setme, const void *content1, int content1_len,...) TR_GNUC_NULL_TERMINATED</td></tr>
<tr class="memdesc:ga26daf1210383c7036369bac7848c77df"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate a SHA1 hash from one or more chunks of memory <br/></td></tr>
<tr class="separator:ga26daf1210383c7036369bac7848c77df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a48597140e5864748d12a21a4e8890e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2a48597140e5864748d12a21a4e8890e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga2a48597140e5864748d12a21a4e8890e">tr_cryptoRandInt</a> (int n)</td></tr>
<tr class="memdesc:ga2a48597140e5864748d12a21a4e8890e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a random number in the range of [0...n) <br/></td></tr>
<tr class="separator:ga2a48597140e5864748d12a21a4e8890e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7b58e744a4c2e0bef38f56f42ec24a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gaa7b58e744a4c2e0bef38f56f42ec24a5">tr_cryptoWeakRandInt</a> (int n)</td></tr>
<tr class="memdesc:gaa7b58e744a4c2e0bef38f56f42ec24a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a pseudorandom number in the range of [0...n)  <a href="#gaa7b58e744a4c2e0bef38f56f42ec24a5">More...</a><br/></td></tr>
<tr class="separator:gaa7b58e744a4c2e0bef38f56f42ec24a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a452efd98992ac49178fdedb9db67c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7a452efd98992ac49178fdedb9db67c3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga7a452efd98992ac49178fdedb9db67c3">tr_cryptoRandBuf</a> (void *buf, size_t len)</td></tr>
<tr class="memdesc:ga7a452efd98992ac49178fdedb9db67c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">fill a buffer with random bytes <br/></td></tr>
<tr class="separator:ga7a452efd98992ac49178fdedb9db67c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga838dbadcc57691c4efa03f5f2c673f42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga838dbadcc57691c4efa03f5f2c673f42"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga838dbadcc57691c4efa03f5f2c673f42">tr_ssha1</a> (const void *plaintext)</td></tr>
<tr class="memdesc:ga838dbadcc57691c4efa03f5f2c673f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate a SSHA password from its plaintext source <br/></td></tr>
<tr class="separator:ga838dbadcc57691c4efa03f5f2c673f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2880dcd29a4e1af12d59eb8eb4c4a89"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad2880dcd29a4e1af12d59eb8eb4c4a89"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gad2880dcd29a4e1af12d59eb8eb4c4a89">tr_ssha1_matches</a> (const char *ssha1, const char *pass)</td></tr>
<tr class="memdesc:gad2880dcd29a4e1af12d59eb8eb4c4a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a test password against the a ssha1 password. <br/></td></tr>
<tr class="separator:gad2880dcd29a4e1af12d59eb8eb4c4a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49eb207b89e512cad36410a0e6f66085"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga49eb207b89e512cad36410a0e6f66085">tr_list_size</a> (const <a class="el" href="structtr__list.html">tr_list</a> *list)</td></tr>
<tr class="memdesc:ga49eb207b89e512cad36410a0e6f66085"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of items in the list  <a href="#ga49eb207b89e512cad36410a0e6f66085">More...</a><br/></td></tr>
<tr class="separator:ga49eb207b89e512cad36410a0e6f66085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfd1968d283044609026af02e7efbf73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gadfd1968d283044609026af02e7efbf73">tr_list_free</a> (<a class="el" href="structtr__list.html">tr_list</a> **list, TrListForeachFunc data_free_func)</td></tr>
<tr class="memdesc:gadfd1968d283044609026af02e7efbf73"><td class="mdescLeft">&#160;</td><td class="mdescRight">free the specified list and set its pointer to NULL  <a href="#gadfd1968d283044609026af02e7efbf73">More...</a><br/></td></tr>
<tr class="separator:gadfd1968d283044609026af02e7efbf73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga638059f2b30c6216de9a8331c725cf13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga638059f2b30c6216de9a8331c725cf13">tr_list_append</a> (<a class="el" href="structtr__list.html">tr_list</a> **list, void *data)</td></tr>
<tr class="memdesc:ga638059f2b30c6216de9a8331c725cf13"><td class="mdescLeft">&#160;</td><td class="mdescRight">append an item to the specified list  <a href="#ga638059f2b30c6216de9a8331c725cf13">More...</a><br/></td></tr>
<tr class="separator:ga638059f2b30c6216de9a8331c725cf13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga323afe1cf6ab58a83f11b43907b9fe70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga323afe1cf6ab58a83f11b43907b9fe70">tr_list_prepend</a> (<a class="el" href="structtr__list.html">tr_list</a> **list, void *data)</td></tr>
<tr class="memdesc:ga323afe1cf6ab58a83f11b43907b9fe70"><td class="mdescLeft">&#160;</td><td class="mdescRight">prepend an item to the specified list  <a href="#ga323afe1cf6ab58a83f11b43907b9fe70">More...</a><br/></td></tr>
<tr class="separator:ga323afe1cf6ab58a83f11b43907b9fe70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga599afcc9842a98916ff2959eeb6ae97d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga599afcc9842a98916ff2959eeb6ae97d">tr_list_pop_front</a> (<a class="el" href="structtr__list.html">tr_list</a> **list)</td></tr>
<tr class="memdesc:ga599afcc9842a98916ff2959eeb6ae97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove the next item in the list  <a href="#ga599afcc9842a98916ff2959eeb6ae97d">More...</a><br/></td></tr>
<tr class="separator:ga599afcc9842a98916ff2959eeb6ae97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a41bbc81f7c35e2b2d1831d6b198ec0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga9a41bbc81f7c35e2b2d1831d6b198ec0">tr_list_remove_data</a> (<a class="el" href="structtr__list.html">tr_list</a> **list, const void *data)</td></tr>
<tr class="memdesc:ga9a41bbc81f7c35e2b2d1831d6b198ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove the list's node that contains the specified data pointer  <a href="#ga9a41bbc81f7c35e2b2d1831d6b198ec0">More...</a><br/></td></tr>
<tr class="separator:ga9a41bbc81f7c35e2b2d1831d6b198ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5fee0228e00e99047d791f3130667f4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gae5fee0228e00e99047d791f3130667f4">tr_list_remove</a> (<a class="el" href="structtr__list.html">tr_list</a> **list, const void *b, TrListCompareFunc compare_func)</td></tr>
<tr class="memdesc:gae5fee0228e00e99047d791f3130667f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove the list's node that compares equal to "b" when compared with "compare_func"  <a href="#gae5fee0228e00e99047d791f3130667f4">More...</a><br/></td></tr>
<tr class="separator:gae5fee0228e00e99047d791f3130667f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga222b884ed94f10ca894fbb4af059d961"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtr__list.html">tr_list</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga222b884ed94f10ca894fbb4af059d961">tr_list_find</a> (<a class="el" href="structtr__list.html">tr_list</a> *list, const void *b, TrListCompareFunc compare_func)</td></tr>
<tr class="memdesc:ga222b884ed94f10ca894fbb4af059d961"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the list node whose data that compares equal to "b" when compared with "compare_func"  <a href="#ga222b884ed94f10ca894fbb4af059d961">More...</a><br/></td></tr>
<tr class="separator:ga222b884ed94f10ca894fbb4af059d961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ab7b4c7a2b2d5c62384243d0f16f04e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga9ab7b4c7a2b2d5c62384243d0f16f04e">tr_list_insert_sorted</a> (<a class="el" href="structtr__list.html">tr_list</a> **list, void *data, TrListCompareFunc compare)</td></tr>
<tr class="memdesc:ga9ab7b4c7a2b2d5c62384243d0f16f04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert in an ordered list.  <a href="#ga9ab7b4c7a2b2d5c62384243d0f16f04e">More...</a><br/></td></tr>
<tr class="separator:ga9ab7b4c7a2b2d5c62384243d0f16f04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaee57f67d64e2aa720029f0d041be9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacaee57f67d64e2aa720029f0d041be9a"></a>
<a class="el" href="structtr__thread.html">tr_thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gacaee57f67d64e2aa720029f0d041be9a">tr_threadNew</a> (void(*func)(void *), void *arg)</td></tr>
<tr class="memdesc:gacaee57f67d64e2aa720029f0d041be9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiate a new process thread. <br/></td></tr>
<tr class="separator:gacaee57f67d64e2aa720029f0d041be9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34407e73a5611eff8775242582e1b658"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga34407e73a5611eff8775242582e1b658">tr_amInThread</a> (const <a class="el" href="structtr__thread.html">tr_thread</a> *)</td></tr>
<tr class="memdesc:ga34407e73a5611eff8775242582e1b658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return nonzero if this function is being called from `thread'.  <a href="#ga34407e73a5611eff8775242582e1b658">More...</a><br/></td></tr>
<tr class="separator:ga34407e73a5611eff8775242582e1b658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57c9c0c6b0c42c57373bbef33fb87dad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga57c9c0c6b0c42c57373bbef33fb87dad"></a>
<a class="el" href="structtr__lock.html">tr_lock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga57c9c0c6b0c42c57373bbef33fb87dad">tr_lockNew</a> (void)</td></tr>
<tr class="memdesc:ga57c9c0c6b0c42c57373bbef33fb87dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new thread mutex object. <br/></td></tr>
<tr class="separator:ga57c9c0c6b0c42c57373bbef33fb87dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b9cfc806a17e9d066b243b5e0022786"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0b9cfc806a17e9d066b243b5e0022786"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga0b9cfc806a17e9d066b243b5e0022786">tr_lockFree</a> (<a class="el" href="structtr__lock.html">tr_lock</a> *)</td></tr>
<tr class="memdesc:ga0b9cfc806a17e9d066b243b5e0022786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a thread mutex object. <br/></td></tr>
<tr class="separator:ga0b9cfc806a17e9d066b243b5e0022786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4b1250a86588574884c8f957b445756"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa4b1250a86588574884c8f957b445756"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gaa4b1250a86588574884c8f957b445756">tr_lockLock</a> (<a class="el" href="structtr__lock.html">tr_lock</a> *)</td></tr>
<tr class="memdesc:gaa4b1250a86588574884c8f957b445756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to lock a thread mutex object. <br/></td></tr>
<tr class="separator:gaa4b1250a86588574884c8f957b445756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00cf6dd5c5e9b00944920878e8a09008"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga00cf6dd5c5e9b00944920878e8a09008"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga00cf6dd5c5e9b00944920878e8a09008">tr_lockUnlock</a> (<a class="el" href="structtr__lock.html">tr_lock</a> *)</td></tr>
<tr class="memdesc:ga00cf6dd5c5e9b00944920878e8a09008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a thread mutex object. <br/></td></tr>
<tr class="separator:ga00cf6dd5c5e9b00944920878e8a09008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65c372ce86ddb00c8250961e5ac08972"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga65c372ce86ddb00c8250961e5ac08972"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga65c372ce86ddb00c8250961e5ac08972">tr_lockHave</a> (const <a class="el" href="structtr__lock.html">tr_lock</a> *)</td></tr>
<tr class="memdesc:ga65c372ce86ddb00c8250961e5ac08972"><td class="mdescLeft">&#160;</td><td class="mdescRight">return nonzero if the specified lock is locked <br/></td></tr>
<tr class="separator:ga65c372ce86ddb00c8250961e5ac08972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5b6c7d65a4f663c6c256e5953af36e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac5b6c7d65a4f663c6c256e5953af36e6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gac5b6c7d65a4f663c6c256e5953af36e6">tr_ptrArrayDestruct</a> (<a class="el" href="structtr__ptrArray.html">tr_ptrArray</a> *, PtrArrayForeachFunc func)</td></tr>
<tr class="memdesc:gac5b6c7d65a4f663c6c256e5953af36e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor to free a <a class="el" href="structtr__ptrArray.html" title="simple pointer array that resizes itself dynamically. ">tr_ptrArray</a>'s internal memory. <br/></td></tr>
<tr class="separator:gac5b6c7d65a4f663c6c256e5953af36e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4efe1f1c00d27510eeb7b041078d05ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4efe1f1c00d27510eeb7b041078d05ce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga4efe1f1c00d27510eeb7b041078d05ce">tr_ptrArrayForeach</a> (<a class="el" href="structtr__ptrArray.html">tr_ptrArray</a> *array, PtrArrayForeachFunc func)</td></tr>
<tr class="memdesc:ga4efe1f1c00d27510eeb7b041078d05ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate through each item in a <a class="el" href="structtr__ptrArray.html" title="simple pointer array that resizes itself dynamically. ">tr_ptrArray</a>. <br/></td></tr>
<tr class="separator:ga4efe1f1c00d27510eeb7b041078d05ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49acce25b639b4402871f10706b7d570"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga49acce25b639b4402871f10706b7d570">tr_ptrArrayPop</a> (<a class="el" href="structtr__ptrArray.html">tr_ptrArray</a> *array)</td></tr>
<tr class="memdesc:ga49acce25b639b4402871f10706b7d570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last item from the array and return it.  <a href="#ga49acce25b639b4402871f10706b7d570">More...</a><br/></td></tr>
<tr class="separator:ga49acce25b639b4402871f10706b7d570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaf1c960f850f8bb675ab503165bb5ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeaf1c960f850f8bb675ab503165bb5ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tr_ptrArrayErase</b> (<a class="el" href="structtr__ptrArray.html">tr_ptrArray</a> *t, int begin, int end)</td></tr>
<tr class="separator:gaeaf1c960f850f8bb675ab503165bb5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1056ca1f893e9b01de20b20fdedc400f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1056ca1f893e9b01de20b20fdedc400f"></a>
void **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga1056ca1f893e9b01de20b20fdedc400f">tr_ptrArrayPeek</a> (<a class="el" href="structtr__ptrArray.html">tr_ptrArray</a> *array, int *size)</td></tr>
<tr class="memdesc:ga1056ca1f893e9b01de20b20fdedc400f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at the array pointer and its size, for easy iteration. <br/></td></tr>
<tr class="separator:ga1056ca1f893e9b01de20b20fdedc400f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62a9e2031ddbf3b44cfc07e9543e979b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga62a9e2031ddbf3b44cfc07e9543e979b">tr_ptrArrayInsert</a> (<a class="el" href="structtr__ptrArray.html">tr_ptrArray</a> *array, void *insertMe, int pos)</td></tr>
<tr class="memdesc:ga62a9e2031ddbf3b44cfc07e9543e979b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a pointer into the array at the specified position.  <a href="#ga62a9e2031ddbf3b44cfc07e9543e979b">More...</a><br/></td></tr>
<tr class="separator:ga62a9e2031ddbf3b44cfc07e9543e979b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b5ebac760bb1542ceb95dc5ef047c3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1b5ebac760bb1542ceb95dc5ef047c3d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>tr_ptrArrayLowerBound</b> (const <a class="el" href="structtr__ptrArray.html">tr_ptrArray</a> *array, const void *key, int compare(const void *arrayItem, const void *key), bool *exact_match)</td></tr>
<tr class="separator:ga1b5ebac760bb1542ceb95dc5ef047c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79d50efe759344092e56b04583dafd4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga79d50efe759344092e56b04583dafd4c">tr_ptrArrayInsertSorted</a> (<a class="el" href="structtr__ptrArray.html">tr_ptrArray</a> *array, void *value, int compare(const void *, const void *))</td></tr>
<tr class="memdesc:ga79d50efe759344092e56b04583dafd4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a pointer into the array at the position determined by the sort function.  <a href="#ga79d50efe759344092e56b04583dafd4c">More...</a><br/></td></tr>
<tr class="separator:ga79d50efe759344092e56b04583dafd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8918888341d017a45b1e5d2548ce00ee"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga8918888341d017a45b1e5d2548ce00ee">tr_ptrArrayRemoveSorted</a> (<a class="el" href="structtr__ptrArray.html">tr_ptrArray</a> *array, const void *value, int compare(const void *, const void *))</td></tr>
<tr class="memdesc:ga8918888341d017a45b1e5d2548ce00ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a pointer from an array sorted by the specified sort function.  <a href="#ga8918888341d017a45b1e5d2548ce00ee">More...</a><br/></td></tr>
<tr class="separator:ga8918888341d017a45b1e5d2548ce00ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a454a56eec751a52b7b18b14ca4fe09"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga4a454a56eec751a52b7b18b14ca4fe09">tr_ptrArrayFindSorted</a> (<a class="el" href="structtr__ptrArray.html">tr_ptrArray</a> *array, const void *key, int compare(const void *, const void *))</td></tr>
<tr class="memdesc:ga4a454a56eec751a52b7b18b14ca4fe09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a pointer from an array sorted by the specified sort function.  <a href="#ga4a454a56eec751a52b7b18b14ca4fe09">More...</a><br/></td></tr>
<tr class="separator:ga4a454a56eec751a52b7b18b14ca4fe09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aceef9c29208e1c4281c9edbbea71a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga4aceef9c29208e1c4281c9edbbea71a3">tr_getopt</a> (const char *summary, int argc, const char **argv, const <a class="el" href="structtr__option.html">tr_option</a> *opts, const char **setme_optarg)</td></tr>
<tr class="memdesc:ga4aceef9c29208e1c4281c9edbbea71a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">similar to getopt ()  <a href="#ga4aceef9c29208e1c4281c9edbbea71a3">More...</a><br/></td></tr>
<tr class="separator:ga4aceef9c29208e1c4281c9edbbea71a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga183ff9eef786e2e3eb3e9408b08bdbbf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga183ff9eef786e2e3eb3e9408b08bdbbf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga183ff9eef786e2e3eb3e9408b08bdbbf">tr_getopt_usage</a> (const char *appName, const char *description, const <a class="el" href="structtr__option.html">tr_option</a> *opts)</td></tr>
<tr class="memdesc:ga183ff9eef786e2e3eb3e9408b08bdbbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints the `Usage' help section to stdout <br/></td></tr>
<tr class="separator:ga183ff9eef786e2e3eb3e9408b08bdbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ace44fa35f797f83bb4d0fa4e4717af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4ace44fa35f797f83bb4d0fa4e4717af"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>tr_strip_positional_args</b> (const char *fmt)</td></tr>
<tr class="separator:ga4ace44fa35f797f83bb4d0fa4e4717af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15cc1c8c721d921dde41b2da3331e1c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga15cc1c8c721d921dde41b2da3331e1c4">tr_wildmat</a> (const char *text, const char *pattern) TR_GNUC_NONNULL(1</td></tr>
<tr class="memdesc:ga15cc1c8c721d921dde41b2da3331e1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rich Salz's classic implementation of shell-style pattern matching for ?, \, [], and * characters.  <a href="#ga15cc1c8c721d921dde41b2da3331e1c4">More...</a><br/></td></tr>
<tr class="separator:ga15cc1c8c721d921dde41b2da3331e1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab863f6a9153f95120e29c0bb789b6d1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab863f6a9153f95120e29c0bb789b6d1e"></a>
bool char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gab863f6a9153f95120e29c0bb789b6d1e">tr_basename</a> (const char *path) TR_GNUC_MALLOC</td></tr>
<tr class="memdesc:gab863f6a9153f95120e29c0bb789b6d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portability wrapper for basename () that uses the system implementation if available. <br/></td></tr>
<tr class="separator:gab863f6a9153f95120e29c0bb789b6d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaefcc4e4934687d213bda0726febe6c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaefcc4e4934687d213bda0726febe6c8"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gaaefcc4e4934687d213bda0726febe6c8">tr_dirname</a> (const char *path) TR_GNUC_MALLOC</td></tr>
<tr class="memdesc:gaaefcc4e4934687d213bda0726febe6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portability wrapper for dirname () that uses the system implementation if available. <br/></td></tr>
<tr class="separator:gaaefcc4e4934687d213bda0726febe6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43a18d450f6946ececa571b7f1ebfb18"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga43a18d450f6946ececa571b7f1ebfb18">tr_mkdirp</a> (const char *path, int permissions) TR_GNUC_NONNULL(1)</td></tr>
<tr class="separator:ga43a18d450f6946ececa571b7f1ebfb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad75e09d5c8779bb306d94c3b11ff8b4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad75e09d5c8779bb306d94c3b11ff8b4c"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gad75e09d5c8779bb306d94c3b11ff8b4c">tr_mkdtemp</a> (char *_template)</td></tr>
<tr class="memdesc:gad75e09d5c8779bb306d94c3b11ff8b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portability wrapper for mkdtemp () that uses the system implementation if available. <br/></td></tr>
<tr class="separator:gad75e09d5c8779bb306d94c3b11ff8b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56db77be7d09bcf732762c577c13611a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga56db77be7d09bcf732762c577c13611a"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga56db77be7d09bcf732762c577c13611a">tr_loadFile</a> (const char *filename, size_t *size) TR_GNUC_MALLOC TR_GNUC_NONNULL(1)</td></tr>
<tr class="memdesc:ga56db77be7d09bcf732762c577c13611a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a file and returns its contents. On failure, NULL is returned and errno is set. <br/></td></tr>
<tr class="separator:ga56db77be7d09bcf732762c577c13611a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabe0573516da4e8c2f0e301ea09807d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaabe0573516da4e8c2f0e301ea09807d4"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gaabe0573516da4e8c2f0e301ea09807d4">tr_buildPath</a> (const char *first_element,...) TR_GNUC_NULL_TERMINATED TR_GNUC_MALLOC</td></tr>
<tr class="memdesc:gaabe0573516da4e8c2f0e301ea09807d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">build a filename from a series of elements using the platform's correct directory separator. <br/></td></tr>
<tr class="separator:gaabe0573516da4e8c2f0e301ea09807d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e29b86c98bddfaf46f4db3a77960a1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8e29b86c98bddfaf46f4db3a77960a1f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>tr_fileExists</b> (const char *filename, time_t *mtime)</td></tr>
<tr class="separator:ga8e29b86c98bddfaf46f4db3a77960a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3c91fdda5d08a6cf15fb91eb822f80c"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gad3c91fdda5d08a6cf15fb91eb822f80c">tr_getDirFreeSpace</a> (const char *path)</td></tr>
<tr class="memdesc:gad3c91fdda5d08a6cf15fb91eb822f80c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get available disk space (in bytes) for the specified folder.  <a href="#gad3c91fdda5d08a6cf15fb91eb822f80c">More...</a><br/></td></tr>
<tr class="separator:gad3c91fdda5d08a6cf15fb91eb822f80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga110e86ad5b0d95dd027b86dcda5f9240"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga110e86ad5b0d95dd027b86dcda5f9240">tr_timerAdd</a> (struct event *timer, int seconds, int microseconds) TR_GNUC_NONNULL(1)</td></tr>
<tr class="memdesc:ga110e86ad5b0d95dd027b86dcda5f9240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper around timer_add () to have a timer wake up in a number of seconds and microseconds.  <a href="#ga110e86ad5b0d95dd027b86dcda5f9240">More...</a><br/></td></tr>
<tr class="separator:ga110e86ad5b0d95dd027b86dcda5f9240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa8f64c97f0adff6a330abca6d07a789"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gaaa8f64c97f0adff6a330abca6d07a789">tr_timerAddMsec</a> (struct event *timer, int milliseconds) TR_GNUC_NONNULL(1)</td></tr>
<tr class="memdesc:gaaa8f64c97f0adff6a330abca6d07a789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper around timer_add () to have a timer wake up in a number of milliseconds.  <a href="#gaaa8f64c97f0adff6a330abca6d07a789">More...</a><br/></td></tr>
<tr class="separator:gaaa8f64c97f0adff6a330abca6d07a789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41fedb32a3cdb86624bf204e8a550a9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga41fedb32a3cdb86624bf204e8a550a9c"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga41fedb32a3cdb86624bf204e8a550a9c">tr_time_msec</a> (void)</td></tr>
<tr class="memdesc:ga41fedb32a3cdb86624bf204e8a550a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the current date in milliseconds <br/></td></tr>
<tr class="separator:ga41fedb32a3cdb86624bf204e8a550a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b69d17cf1f3182a160fa02d6660cbe1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0b69d17cf1f3182a160fa02d6660cbe1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga0b69d17cf1f3182a160fa02d6660cbe1">tr_wait_msec</a> (long int delay_milliseconds)</td></tr>
<tr class="memdesc:ga0b69d17cf1f3182a160fa02d6660cbe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">sleep the specified number of milliseconds <br/></td></tr>
<tr class="separator:ga0b69d17cf1f3182a160fa02d6660cbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fb641ec85cdeb5a7f6bc209d839b281"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga7fb641ec85cdeb5a7f6bc209d839b281">tr_utf8clean</a> (const char *str, int len) TR_GNUC_MALLOC</td></tr>
<tr class="memdesc:ga7fb641ec85cdeb5a7f6bc209d839b281"><td class="mdescLeft">&#160;</td><td class="mdescRight">make a copy of 'str' whose non-utf8 content has been corrected or stripped  <a href="#ga7fb641ec85cdeb5a7f6bc209d839b281">More...</a><br/></td></tr>
<tr class="separator:ga7fb641ec85cdeb5a7f6bc209d839b281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecbf1a6df2e4c1e5a6ae39fb063d6871"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaecbf1a6df2e4c1e5a6ae39fb063d6871"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gaecbf1a6df2e4c1e5a6ae39fb063d6871">tr_malloc</a> (size_t size)</td></tr>
<tr class="memdesc:gaecbf1a6df2e4c1e5a6ae39fb063d6871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portability wrapper around malloc () in which `0' is a safe argument. <br/></td></tr>
<tr class="separator:gaecbf1a6df2e4c1e5a6ae39fb063d6871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4958bd86048009cb5bc24baa46626043"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4958bd86048009cb5bc24baa46626043"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga4958bd86048009cb5bc24baa46626043">tr_malloc0</a> (size_t size)</td></tr>
<tr class="memdesc:ga4958bd86048009cb5bc24baa46626043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portability wrapper around calloc () in which `0' is a safe argument. <br/></td></tr>
<tr class="separator:ga4958bd86048009cb5bc24baa46626043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57ae8c2a5e1f60b7085ba5eb825c95ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga57ae8c2a5e1f60b7085ba5eb825c95ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga57ae8c2a5e1f60b7085ba5eb825c95ab">tr_free</a> (void *p)</td></tr>
<tr class="memdesc:ga57ae8c2a5e1f60b7085ba5eb825c95ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portability wrapper around free () in which `NULL' is a safe argument. <br/></td></tr>
<tr class="separator:ga57ae8c2a5e1f60b7085ba5eb825c95ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga235e4292816e3ad0bb0baaeafb9972a1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga235e4292816e3ad0bb0baaeafb9972a1">tr_memdup</a> (const void *src, size_t byteCount)</td></tr>
<tr class="memdesc:ga235e4292816e3ad0bb0baaeafb9972a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">make a newly-allocated copy of a chunk of memory  <a href="#ga235e4292816e3ad0bb0baaeafb9972a1">More...</a><br/></td></tr>
<tr class="separator:ga235e4292816e3ad0bb0baaeafb9972a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9db08b926396bf67c9dfab5c7cd5db0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad9db08b926396bf67c9dfab5c7cd5db0"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>tr_valloc</b> (size_t bufLen)</td></tr>
<tr class="separator:gad9db08b926396bf67c9dfab5c7cd5db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d26e30c8eccbecc8033f854290c23fd"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga4d26e30c8eccbecc8033f854290c23fd">tr_strndup</a> (const void *in, int len) TR_GNUC_MALLOC</td></tr>
<tr class="memdesc:ga4d26e30c8eccbecc8033f854290c23fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">make a newly-allocated copy of a substring  <a href="#ga4d26e30c8eccbecc8033f854290c23fd">More...</a><br/></td></tr>
<tr class="separator:ga4d26e30c8eccbecc8033f854290c23fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7964b8593b35ec257854c48bc351025d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga7964b8593b35ec257854c48bc351025d">tr_strdup</a> (const void *in)</td></tr>
<tr class="memdesc:ga7964b8593b35ec257854c48bc351025d"><td class="mdescLeft">&#160;</td><td class="mdescRight">make a newly-allocated copy of a string  <a href="#ga7964b8593b35ec257854c48bc351025d">More...</a><br/></td></tr>
<tr class="separator:ga7964b8593b35ec257854c48bc351025d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab976524d13c54ff21221fbe06338dce4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab976524d13c54ff21221fbe06338dce4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gab976524d13c54ff21221fbe06338dce4">tr_strcmp0</a> (const char *str1, const char *str2)</td></tr>
<tr class="memdesc:gab976524d13c54ff21221fbe06338dce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">like strcmp () but gracefully handles NULL strings <br/></td></tr>
<tr class="separator:gab976524d13c54ff21221fbe06338dce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa40443020fa203971b961db3b5fa83c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa40443020fa203971b961db3b5fa83c0"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>evbuffer_free_to_str</b> (struct evbuffer *buf)</td></tr>
<tr class="separator:gaa40443020fa203971b961db3b5fa83c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d1065b64ba126f02006b513b3496631"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9d1065b64ba126f02006b513b3496631"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga9d1065b64ba126f02006b513b3496631">tr_lowerBound</a> (const void *key, const void *base, size_t nmemb, size_t size, int(*compar)(const void *key, const void *arrayMember), bool *exact_match) TR_GNUC_HOT TR_GNUC_NONNULL(1</td></tr>
<tr class="memdesc:ga9d1065b64ba126f02006b513b3496631"><td class="mdescLeft">&#160;</td><td class="mdescRight">similar to bsearch () but returns the index of the lower bound <br/></td></tr>
<tr class="separator:ga9d1065b64ba126f02006b513b3496631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bd2a175cfad4df0cb2dfaa917af3252"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0bd2a175cfad4df0cb2dfaa917af3252"></a>
int void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga0bd2a175cfad4df0cb2dfaa917af3252">tr_quickfindFirstK</a> (void *base, size_t nmemb, size_t size, int(*compar)(const void *, const void *), size_t k)</td></tr>
<tr class="memdesc:ga0bd2a175cfad4df0cb2dfaa917af3252"><td class="mdescLeft">&#160;</td><td class="mdescRight">moves the best k items to the first slots in the array. O(n) <br/></td></tr>
<tr class="separator:ga0bd2a175cfad4df0cb2dfaa917af3252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace3d07abdd0df33bda6c8290845849a8"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gace3d07abdd0df33bda6c8290845849a8">tr_strdup_printf</a> (const char *fmt,...) TR_GNUC_PRINTF(1</td></tr>
<tr class="memdesc:gace3d07abdd0df33bda6c8290845849a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">sprintf () a string into a newly-allocated buffer large enough to hold it  <a href="#gace3d07abdd0df33bda6c8290845849a8">More...</a><br/></td></tr>
<tr class="separator:gace3d07abdd0df33bda6c8290845849a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd659185316835eb6744d3dec97a6476"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gafd659185316835eb6744d3dec97a6476">tr_base64_encode</a> (const void *input, int inlen, int *outlen) TR_GNUC_MALLOC</td></tr>
<tr class="memdesc:gafd659185316835eb6744d3dec97a6476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a block of bytes into base64.  <a href="#gafd659185316835eb6744d3dec97a6476">More...</a><br/></td></tr>
<tr class="separator:gafd659185316835eb6744d3dec97a6476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadffdc349513ed04e0b3d74c2b483cdd5"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gadffdc349513ed04e0b3d74c2b483cdd5">tr_base64_decode</a> (const void *input, int inlen, int *outlen) TR_GNUC_MALLOC</td></tr>
<tr class="memdesc:gadffdc349513ed04e0b3d74c2b483cdd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a block of bytes from base64 into raw form.  <a href="#gadffdc349513ed04e0b3d74c2b483cdd5">More...</a><br/></td></tr>
<tr class="separator:gadffdc349513ed04e0b3d74c2b483cdd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcdff9a9e3a5a481b3d4433d4a747904"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadcdff9a9e3a5a481b3d4433d4a747904"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gadcdff9a9e3a5a481b3d4433d4a747904">tr_strlcpy</a> (char *dst, const void *src, size_t siz)</td></tr>
<tr class="memdesc:gadcdff9a9e3a5a481b3d4433d4a747904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portability wrapper for strlcpy () that uses the system implementation if available. <br/></td></tr>
<tr class="separator:gadcdff9a9e3a5a481b3d4433d4a747904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcdacec7d21d057fde959869468fd8dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadcdacec7d21d057fde959869468fd8dd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gadcdacec7d21d057fde959869468fd8dd">tr_snprintf</a> (char *buf, size_t buflen, const char *fmt,...) TR_GNUC_PRINTF(3</td></tr>
<tr class="memdesc:gadcdacec7d21d057fde959869468fd8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portability wrapper for snprintf () that uses the system implementation if available. <br/></td></tr>
<tr class="separator:gadcdacec7d21d057fde959869468fd8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e6978a826bb319cdc9b260dc663f850"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6e6978a826bb319cdc9b260dc663f850"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>TR_GNUC_NONNULL</b> (1, 3)</td></tr>
<tr class="separator:ga6e6978a826bb319cdc9b260dc663f850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad944142bee1525f6eaaf3854b9c7fe2f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gad944142bee1525f6eaaf3854b9c7fe2f">tr_strerror</a> (int)</td></tr>
<tr class="memdesc:gad944142bee1525f6eaaf3854b9c7fe2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper around strerorr () guaranteed to not return NULL.  <a href="#gad944142bee1525f6eaaf3854b9c7fe2f">More...</a><br/></td></tr>
<tr class="separator:gad944142bee1525f6eaaf3854b9c7fe2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc192fcee2b2eaef436570655f853e68"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gadc192fcee2b2eaef436570655f853e68">tr_strstrip</a> (char *str)</td></tr>
<tr class="memdesc:gadc192fcee2b2eaef436570655f853e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">strips leading and trailing whitspace from a string  <a href="#gadc192fcee2b2eaef436570655f853e68">More...</a><br/></td></tr>
<tr class="separator:gadc192fcee2b2eaef436570655f853e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97db081fb961a0f23b69e5ca01a6a325"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga97db081fb961a0f23b69e5ca01a6a325"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga97db081fb961a0f23b69e5ca01a6a325">tr_str_has_suffix</a> (const char *str, const char *suffix)</td></tr>
<tr class="memdesc:ga97db081fb961a0f23b69e5ca01a6a325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the string ends with the specified case-insensitive suffix. <br/></td></tr>
<tr class="separator:ga97db081fb961a0f23b69e5ca01a6a325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac798dad9357ca26a97984f27330c0130"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac798dad9357ca26a97984f27330c0130"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gac798dad9357ca26a97984f27330c0130">tr_memmem</a> (const char *haystack, size_t haystack_len, const char *needle, size_t needle_len)</td></tr>
<tr class="memdesc:gac798dad9357ca26a97984f27330c0130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portability wrapper for memmem () that uses the system implementation if available. <br/></td></tr>
<tr class="separator:gac798dad9357ca26a97984f27330c0130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81f5429e77ceacf96a92bae1a90443aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga81f5429e77ceacf96a92bae1a90443aa"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga81f5429e77ceacf96a92bae1a90443aa">tr_strsep</a> (char **str, const char *delim)</td></tr>
<tr class="memdesc:ga81f5429e77ceacf96a92bae1a90443aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portability wrapper for strsep () that uses the system implementation if available. <br/></td></tr>
<tr class="separator:ga81f5429e77ceacf96a92bae1a90443aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9be5f71b31c116090c5e96a387fdafe1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9be5f71b31c116090c5e96a387fdafe1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>compareInt</b> (const void *va, const void *vb)</td></tr>
<tr class="separator:ga9be5f71b31c116090c5e96a387fdafe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae600fb179a16ca04aac19d966c27226e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae600fb179a16ca04aac19d966c27226e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tr_sha1_to_hex</b> (char *out, const uint8_t *sha1) TR_GNUC_NONNULL(1</td></tr>
<tr class="separator:gae600fb179a16ca04aac19d966c27226e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1bc1c9690be40d8f538d2b46fe6abe5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac1bc1c9690be40d8f538d2b46fe6abe5"></a>
void void&#160;</td><td class="memItemRight" valign="bottom"><b>tr_hex_to_sha1</b> (uint8_t *out, const char *hex) TR_GNUC_NONNULL(1</td></tr>
<tr class="separator:gac1bc1c9690be40d8f538d2b46fe6abe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea581d17b8d5d029b9af29ca6bf45086"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaea581d17b8d5d029b9af29ca6bf45086"></a>
void void bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gaea581d17b8d5d029b9af29ca6bf45086">tr_addressIsIP</a> (const char *address)</td></tr>
<tr class="memdesc:gaea581d17b8d5d029b9af29ca6bf45086"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience function to determine if an address is an IP address (IPv4 or IPv6) <br/></td></tr>
<tr class="separator:gaea581d17b8d5d029b9af29ca6bf45086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59cc694e8c51c609359fe99afec80073"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga59cc694e8c51c609359fe99afec80073"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga59cc694e8c51c609359fe99afec80073">tr_urlIsValidTracker</a> (const char *url) TR_GNUC_NONNULL(1)</td></tr>
<tr class="memdesc:ga59cc694e8c51c609359fe99afec80073"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if the url is a http or https url that Transmission understands <br/></td></tr>
<tr class="separator:ga59cc694e8c51c609359fe99afec80073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c0c87a406d2b7088d4d266750d0f121"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4c0c87a406d2b7088d4d266750d0f121"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga4c0c87a406d2b7088d4d266750d0f121">tr_urlIsValid</a> (const char *url, int url_len) TR_GNUC_NONNULL(1)</td></tr>
<tr class="memdesc:ga4c0c87a406d2b7088d4d266750d0f121"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if the url is a [ http, https, ftp, ftps ] url that Transmission understands <br/></td></tr>
<tr class="separator:ga4c0c87a406d2b7088d4d266750d0f121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9185d3bd416d17283e91f136d1a0a216"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga9185d3bd416d17283e91f136d1a0a216">tr_urlParse</a> (const char *url, int url_len, char **setme_scheme, char **setme_host, int *setme_port, char **setme_path) TR_GNUC_NONNULL(1)</td></tr>
<tr class="memdesc:ga9185d3bd416d17283e91f136d1a0a216"><td class="mdescLeft">&#160;</td><td class="mdescRight">parse a URL into its component parts  <a href="#ga9185d3bd416d17283e91f136d1a0a216">More...</a><br/></td></tr>
<tr class="separator:ga9185d3bd416d17283e91f136d1a0a216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cf75cabf75c4615ffc88b60e737fe04"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga3cf75cabf75c4615ffc88b60e737fe04">tr_getRatio</a> (uint64_t numerator, uint64_t denominator)</td></tr>
<tr class="memdesc:ga3cf75cabf75c4615ffc88b60e737fe04"><td class="mdescLeft">&#160;</td><td class="mdescRight">return TR_RATIO_NA, TR_RATIO_INF, or a number in [0..1]  <a href="#ga3cf75cabf75c4615ffc88b60e737fe04">More...</a><br/></td></tr>
<tr class="separator:ga3cf75cabf75c4615ffc88b60e737fe04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc70d90f6156f8397d35dfe7ec8b4323"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gafc70d90f6156f8397d35dfe7ec8b4323">tr_parseNumberRange</a> (const char *str, int str_len, int *setmeCount) TR_GNUC_MALLOC TR_GNUC_NONNULL(1)</td></tr>
<tr class="memdesc:gafc70d90f6156f8397d35dfe7ec8b4323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a string like "1-4" or "1-4,6,9,14-51", this returns a newly-allocated array of all the integers in the set.  <a href="#gafc70d90f6156f8397d35dfe7ec8b4323">More...</a><br/></td></tr>
<tr class="separator:gafc70d90f6156f8397d35dfe7ec8b4323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dc03c76ccb0c5cb5e5e55c48d00320b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga5dc03c76ccb0c5cb5e5e55c48d00320b">tr_truncd</a> (double x, int decimal_places)</td></tr>
<tr class="memdesc:ga5dc03c76ccb0c5cb5e5e55c48d00320b"><td class="mdescLeft">&#160;</td><td class="mdescRight">truncate a double value at a given number of decimal places.  <a href="#ga5dc03c76ccb0c5cb5e5e55c48d00320b">More...</a><br/></td></tr>
<tr class="separator:ga5dc03c76ccb0c5cb5e5e55c48d00320b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4ed5a697fbbdd81803b3826480d5388"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae4ed5a697fbbdd81803b3826480d5388"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>tr_strpercent</b> (char *buf, double x, size_t buflen)</td></tr>
<tr class="separator:gae4ed5a697fbbdd81803b3826480d5388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa690c507e07624bd1cb15efd55fd66ec"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gaa690c507e07624bd1cb15efd55fd66ec">tr_strratio</a> (char *buf, size_t buflen, double ratio, const char *infinity) TR_GNUC_NONNULL(1</td></tr>
<tr class="separator:gaa690c507e07624bd1cb15efd55fd66ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga730098b8c6c4b26c56dd43e49716157e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga730098b8c6c4b26c56dd43e49716157e"></a>
char struct tm *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga730098b8c6c4b26c56dd43e49716157e">tr_localtime_r</a> (const time_t *_clock, struct tm *_result)</td></tr>
<tr class="memdesc:ga730098b8c6c4b26c56dd43e49716157e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portability wrapper for localtime_r () that uses the system implementation if available. <br/></td></tr>
<tr class="separator:ga730098b8c6c4b26c56dd43e49716157e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4268dd296a87421af849e8c88800411"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gac4268dd296a87421af849e8c88800411">tr_moveFile</a> (const char *oldpath, const char *newpath, bool *renamed) TR_GNUC_NONNULL(1</td></tr>
<tr class="memdesc:gac4268dd296a87421af849e8c88800411"><td class="mdescLeft">&#160;</td><td class="mdescRight">move a file  <a href="#gac4268dd296a87421af849e8c88800411">More...</a><br/></td></tr>
<tr class="separator:gac4268dd296a87421af849e8c88800411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9c5725a5b8e5d04a213886b309c3f67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab9c5725a5b8e5d04a213886b309c3f67"></a>
int int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gab9c5725a5b8e5d04a213886b309c3f67">tr_rename</a> (const char *oldpath_utf8, const char *newpath_utf8)</td></tr>
<tr class="memdesc:gab9c5725a5b8e5d04a213886b309c3f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portability wrapper for rename () <br/></td></tr>
<tr class="separator:gab9c5725a5b8e5d04a213886b309c3f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3f929bb99d96965263b24be199c788d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa3f929bb99d96965263b24be199c788d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gaa3f929bb99d96965263b24be199c788d">tr_remove</a> (const char *pathname_utf8)</td></tr>
<tr class="memdesc:gaa3f929bb99d96965263b24be199c788d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portability wrapper for remove () <br/></td></tr>
<tr class="separator:gaa3f929bb99d96965263b24be199c788d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3107483dacc48754d4349c1ff7b176e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf3107483dacc48754d4349c1ff7b176e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gaf3107483dacc48754d4349c1ff7b176e">tr_is_same_file</a> (const char *filename1, const char *filename2)</td></tr>
<tr class="memdesc:gaf3107483dacc48754d4349c1ff7b176e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test to see if the two filenames point to the same file. <br/></td></tr>
<tr class="separator:gaf3107483dacc48754d4349c1ff7b176e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06bda51d93f2bb7f96defc8ba20b317f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga06bda51d93f2bb7f96defc8ba20b317f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga06bda51d93f2bb7f96defc8ba20b317f">tr_removeElementFromArray</a> (void *array, unsigned int index_to_remove, size_t sizeof_element, size_t nmemb)</td></tr>
<tr class="memdesc:ga06bda51d93f2bb7f96defc8ba20b317f"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience function to remove an item from an array <br/></td></tr>
<tr class="separator:ga06bda51d93f2bb7f96defc8ba20b317f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d32624e4011205b4c5d8f6fd94e1f74"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga0d32624e4011205b4c5d8f6fd94e1f74">tr_realpath</a> (const char *path, char *resolved_path)</td></tr>
<tr class="memdesc:ga0d32624e4011205b4c5d8f6fd94e1f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portability wrapper for realpath () that uses the system implementation if available.  <a href="#ga0d32624e4011205b4c5d8f6fd94e1f74">More...</a><br/></td></tr>
<tr class="separator:ga0d32624e4011205b4c5d8f6fd94e1f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a1c04991a6b2324adc2eafd60a2dd8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5a1c04991a6b2324adc2eafd60a2dd8c"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga5a1c04991a6b2324adc2eafd60a2dd8c">tr_htonll</a> (uint64_t)</td></tr>
<tr class="memdesc:ga5a1c04991a6b2324adc2eafd60a2dd8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portability wrapper for htonll () that uses the system implementation if available. <br/></td></tr>
<tr class="separator:ga5a1c04991a6b2324adc2eafd60a2dd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae910b46deab8449c3a5f310f28241d7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae910b46deab8449c3a5f310f28241d7a"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gae910b46deab8449c3a5f310f28241d7a">tr_ntohll</a> (uint64_t)</td></tr>
<tr class="memdesc:gae910b46deab8449c3a5f310f28241d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portability wrapper for htonll () that uses the system implementation if available. <br/></td></tr>
<tr class="separator:gae910b46deab8449c3a5f310f28241d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6c3c871309932bfec0c7cf652ae0209"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac6c3c871309932bfec0c7cf652ae0209"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tr_formatter_size_init</b> (unsigned int kilo, const char *kb, const char *mb, const char *gb, const char *tb)</td></tr>
<tr class="separator:gac6c3c871309932bfec0c7cf652ae0209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bb364fccd16f102e49bf4e3c256d05b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2bb364fccd16f102e49bf4e3c256d05b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tr_formatter_speed_init</b> (unsigned int kilo, const char *kb, const char *mb, const char *gb, const char *tb)</td></tr>
<tr class="separator:ga2bb364fccd16f102e49bf4e3c256d05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32ec172b759b8b0e92086953d693def9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga32ec172b759b8b0e92086953d693def9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tr_formatter_mem_init</b> (unsigned int kilo, const char *kb, const char *mb, const char *gb, const char *tb)</td></tr>
<tr class="separator:ga32ec172b759b8b0e92086953d693def9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad54f71ad731bc70b5cd7e5c5a02546a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad54f71ad731bc70b5cd7e5c5a02546a2"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>tr_formatter_speed_KBps</b> (char *buf, double KBps, size_t buflen)</td></tr>
<tr class="separator:gad54f71ad731bc70b5cd7e5c5a02546a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a73891d231918f2a0dd6dc222877b20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9a73891d231918f2a0dd6dc222877b20"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>tr_formatter_mem_B</b> (char *buf, int64_t bytes, size_t buflen)</td></tr>
<tr class="separator:ga9a73891d231918f2a0dd6dc222877b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8ccab8dad3b743f6884f6e08ba0e4b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad8ccab8dad3b743f6884f6e08ba0e4b9"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>tr_formatter_size_B</b> (char *buf, int64_t bytes, size_t buflen)</td></tr>
<tr class="separator:gad8ccab8dad3b743f6884f6e08ba0e4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97749159491ad3640856e2261b53b95d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga97749159491ad3640856e2261b53b95d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tr_formatter_get_units</b> (void *dict)</td></tr>
<tr class="separator:ga97749159491ad3640856e2261b53b95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga2524022f560c40149edff7e29565c0c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2524022f560c40149edff7e29565c0c4"></a>
const <a class="el" href="structtr__ptrArray.html">tr_ptrArray</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TR_PTR_ARRAY_INIT</b></td></tr>
<tr class="separator:ga2524022f560c40149edff7e29565c0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff2845555584f46a6a71dae6c239f231"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaff2845555584f46a6a71dae6c239f231"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#gaff2845555584f46a6a71dae6c239f231">tr_optind</a></td></tr>
<tr class="memdesc:gaff2845555584f46a6a71dae6c239f231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to optind, this is the current index into argv. <br/></td></tr>
<tr class="separator:gaff2845555584f46a6a71dae6c239f231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3537c1c41511b62afc212ba25330d061"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3537c1c41511b62afc212ba25330d061"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>TR_GNUC_MALLOC</b></td></tr>
<tr class="separator:ga3537c1c41511b62afc212ba25330d061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ccf8bfaf08d4b790581b8dec1aeb17f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5ccf8bfaf08d4b790581b8dec1aeb17f"></a>
time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utils.html#ga5ccf8bfaf08d4b790581b8dec1aeb17f">__tr_current_time</a></td></tr>
<tr class="memdesc:ga5ccf8bfaf08d4b790581b8dec1aeb17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private libtransmission variable that's visible only for inlining in tr_time () <br/></td></tr>
<tr class="separator:ga5ccf8bfaf08d4b790581b8dec1aeb17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f08d1c2f41e891964c0f88843e6f7f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4f08d1c2f41e891964c0f88843e6f7f3"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>tr_speed_K</b></td></tr>
<tr class="separator:ga4f08d1c2f41e891964c0f88843e6f7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7520d212061fb866eaef08a8d2cafcd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7520d212061fb866eaef08a8d2cafcd6"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>tr_mem_K</b></td></tr>
<tr class="separator:ga7520d212061fb866eaef08a8d2cafcd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41d616e6075dbc7920d6529f877f6e3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga41d616e6075dbc7920d6529f877f6e3c"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>tr_size_K</b></td></tr>
<tr class="separator:ga41d616e6075dbc7920d6529f877f6e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga34407e73a5611eff8775242582e1b658"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tr_amInThread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtr__thread.html">tr_thread</a> *&#160;</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return nonzero if this function is being called from `thread'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>the thread being tested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadffdc349513ed04e0b3d74c2b483cdd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* tr_base64_decode </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>outlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate a block of bytes from base64 into raw form. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly-allocated string that can be freed with tr_free () </dd></dl>

</div>
</div>
<a class="anchor" id="gafd659185316835eb6744d3dec97a6476"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* tr_base64_encode </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>outlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate a block of bytes into base64. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly-allocated string that can be freed with tr_free () </dd></dl>

</div>
</div>
<a class="anchor" id="gaa7b58e744a4c2e0bef38f56f42ec24a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tr_cryptoWeakRandInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a pseudorandom number in the range of [0...n) </p>
<p>This is faster, BUT WEAKER, than tr_cryptoRandInt () and never be used in sensitive cases. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__utils.html#ga2a48597140e5864748d12a21a4e8890e" title="returns a random number in the range of [0...n) ">tr_cryptoRandInt</a> () </dd></dl>

</div>
</div>
<a class="anchor" id="gad3c91fdda5d08a6cf15fb91eb822f80c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t tr_getDirFreeSpace </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get available disk space (in bytes) for the specified folder. </p>
<dl class="section return"><dt>Returns</dt><dd>zero or positive integer on success, -1 in case of error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4aceef9c29208e1c4281c9edbbea71a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tr_getopt </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>summary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtr__option.html">tr_option</a> *&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>setme_optarg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>similar to getopt () </p>
<dl class="section return"><dt>Returns</dt><dd>TR_GETOPT_DONE, TR_GETOPT_ERR, TR_GETOPT_UNK, or the matching <a class="el" href="structtr__option.html">tr_option</a>'s `val' field </dd></dl>

</div>
</div>
<a class="anchor" id="ga3cf75cabf75c4615ffc88b60e737fe04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tr_getRatio </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>numerator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>denominator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return TR_RATIO_NA, TR_RATIO_INF, or a number in [0..1] </p>
<dl class="section return"><dt>Returns</dt><dd>TR_RATIO_NA, TR_RATIO_INF, or a number in [0..1] </dd></dl>

</div>
</div>
<a class="anchor" id="ga638059f2b30c6216de9a8331c725cf13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tr_list_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtr__list.html">tr_list</a> **&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>append an item to the specified list </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>pointer to the list </td></tr>
    <tr><td class="paramname">item</td><td>the item to append </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga222b884ed94f10ca894fbb4af059d961"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtr__list.html">tr_list</a>* tr_list_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtr__list.html">tr_list</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TrListCompareFunc&#160;</td>
          <td class="paramname"><em>compare_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find the list node whose data that compares equal to "b" when compared with "compare_func" </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>pointer to the list </td></tr>
    <tr><td class="paramname">b</td><td>the comparison key </td></tr>
    <tr><td class="paramname">compare_func</td><td>the comparison function. The arguments passed to it will be the list's pointers and the comparison key "b" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching list node, or NULL if not match was found </dd></dl>

</div>
</div>
<a class="anchor" id="gadfd1968d283044609026af02e7efbf73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tr_list_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtr__list.html">tr_list</a> **&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TrListForeachFunc&#160;</td>
          <td class="paramname"><em>data_free_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>free the specified list and set its pointer to NULL </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>pointer to the list to be freed </td></tr>
    <tr><td class="paramname">func</td><td>optional function to invoke on each item in the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9ab7b4c7a2b2d5c62384243d0f16f04e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tr_list_insert_sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtr__list.html">tr_list</a> **&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TrListCompareFunc&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert in an ordered list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>pointer to the list </td></tr>
    <tr><td class="paramname">item</td><td>the item to be inserted </td></tr>
    <tr><td class="paramname">compare</td><td>the comparison function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga599afcc9842a98916ff2959eeb6ae97d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* tr_list_pop_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtr__list.html">tr_list</a> **&#160;</td>
          <td class="paramname"><em>list</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remove the next item in the list </p>
<dl class="section return"><dt>Returns</dt><dd>the next item in the list, or NULL if the list is empty </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>pointer to the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga323afe1cf6ab58a83f11b43907b9fe70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tr_list_prepend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtr__list.html">tr_list</a> **&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prepend an item to the specified list </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>pointer to the list </td></tr>
    <tr><td class="paramname">item</td><td>the item to prepend </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae5fee0228e00e99047d791f3130667f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* tr_list_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtr__list.html">tr_list</a> **&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TrListCompareFunc&#160;</td>
          <td class="paramname"><em>compare_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remove the list's node that compares equal to "b" when compared with "compare_func" </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>pointer to the list </td></tr>
    <tr><td class="paramname">b</td><td>the comparison key </td></tr>
    <tr><td class="paramname">compare_func</td><td>the comparison function. The arguments passed to it will be the list's pointers and the comparison key "b" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the removed data pointer, or NULL if no match was found </dd></dl>

</div>
</div>
<a class="anchor" id="ga9a41bbc81f7c35e2b2d1831d6b198ec0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* tr_list_remove_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtr__list.html">tr_list</a> **&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remove the list's node that contains the specified data pointer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>pointer to the list </td></tr>
    <tr><td class="paramname">data</td><td>data to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the removed data pointer, or NULL if no match was found </dd></dl>

</div>
</div>
<a class="anchor" id="ga49eb207b89e512cad36410a0e6f66085"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tr_list_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtr__list.html">tr_list</a> *&#160;</td>
          <td class="paramname"><em>list</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the number of items in the list </p>
<dl class="section return"><dt>Returns</dt><dd>the number of items in the list </dd></dl>

</div>
</div>
<a class="anchor" id="ga235e4292816e3ad0bb0baaeafb9972a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* tr_memdup </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make a newly-allocated copy of a chunk of memory </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the memory to copy </td></tr>
    <tr><td class="paramname">byteCount</td><td>the number of bytes to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly-allocated copy of `src' that can be freed with tr_free () </dd></dl>

</div>
</div>
<a class="anchor" id="ga43a18d450f6946ececa571b7f1ebfb18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tr_mkdirp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>permissions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like mkdir, but makes parent directories as needed.</p>
<dl class="section return"><dt>Returns</dt><dd>zero on success, or -1 if an error occurred (in which case errno is set appropriately). </dd></dl>

</div>
</div>
<a class="anchor" id="gac4268dd296a87421af849e8c88800411"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tr_moveFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>oldpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>renamed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>move a file </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success; otherwise, return -1 and set errno </dd></dl>

</div>
</div>
<a class="anchor" id="gafc70d90f6156f8397d35dfe7ec8b4323"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* tr_parseNumberRange </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>setmeCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a string like "1-4" or "1-4,6,9,14-51", this returns a newly-allocated array of all the integers in the set. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly-allocated array of integers that must be freed with tr_free (), or NULL if a fragment of the string can't be parsed.</dd></dl>
<p>For example, "5-8" will return [ 5, 6, 7, 8 ] and setmeCount will be 4.</p>
<p>Given a string like "1-4" or "1-4,6,9,14-51", this allocates and returns an array of setmeCount ints of all the values in the array. For example, "5-8" will return [ 5, 6, 7, 8 ] and setmeCount will be 4. It's the caller's responsibility to call tr_free () on the returned array. If a fragment of the string can't be parsed, NULL is returned. </p>

</div>
</div>
<a class="anchor" id="ga4a454a56eec751a52b7b18b14ca4fe09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* tr_ptrArrayFindSorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtr__ptrArray.html">tr_ptrArray</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>compare</em>const void *, const void *&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a pointer from an array sorted by the specified sort function. </p>
<dl class="section return"><dt>Returns</dt><dd>the matching pointer, or NULL if no match was found </dd></dl>

</div>
</div>
<a class="anchor" id="ga62a9e2031ddbf3b44cfc07e9543e979b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tr_ptrArrayInsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtr__ptrArray.html">tr_ptrArray</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>insertMe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a pointer into the array at the specified position. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of the stored pointer </dd></dl>

</div>
</div>
<a class="anchor" id="ga79d50efe759344092e56b04583dafd4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tr_ptrArrayInsertSorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtr__ptrArray.html">tr_ptrArray</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>compare</em>const void *, const void *&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a pointer into the array at the position determined by the sort function. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of the stored pointer </dd></dl>

</div>
</div>
<a class="anchor" id="ga49acce25b639b4402871f10706b7d570"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* tr_ptrArrayPop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtr__ptrArray.html">tr_ptrArray</a> *&#160;</td>
          <td class="paramname"><em>array</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the last item from the array and return it. </p>
<dl class="section return"><dt>Returns</dt><dd>the pointer that's been removed from the array </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>tr_ptrArrayBack () </dd></dl>

</div>
</div>
<a class="anchor" id="ga8918888341d017a45b1e5d2548ce00ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* tr_ptrArrayRemoveSorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtr__ptrArray.html">tr_ptrArray</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>compare</em>const void *, const void *&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a pointer from an array sorted by the specified sort function. </p>
<dl class="section return"><dt>Returns</dt><dd>the matching pointer, or NULL if no match was found </dd></dl>

</div>
</div>
<a class="anchor" id="ga0d32624e4011205b4c5d8f6fd94e1f74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* tr_realpath </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>resolved_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Portability wrapper for realpath () that uses the system implementation if available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolved_path</td><td>should be TR_PATH_MAX or larger </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7964b8593b35ec257854c48bc351025d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* tr_strdup </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>in</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make a newly-allocated copy of a string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>is a void* so that callers can pass in both signed &amp; unsigned without a cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly-allocated copy of `in' that can be freed with tr_free () </dd></dl>

</div>
</div>
<a class="anchor" id="gace3d07abdd0df33bda6c8290845849a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* tr_strdup_printf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sprintf () a string into a newly-allocated buffer large enough to hold it </p>
<dl class="section return"><dt>Returns</dt><dd>a newly-allocated string that can be freed with tr_free () </dd></dl>

</div>
</div>
<a class="anchor" id="gad944142bee1525f6eaaf3854b9c7fe2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* tr_strerror </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience wrapper around strerorr () guaranteed to not return NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errno</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4d26e30c8eccbecc8033f854290c23fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* tr_strndup </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make a newly-allocated copy of a substring </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>is a void* so that callers can pass in both signed &amp; unsigned without a cast </td></tr>
    <tr><td class="paramname">len</td><td>length of the substring to copy. if a length less than zero is passed in, strlen (len) is used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly-allocated copy of `in' that can be freed with tr_free () </dd></dl>

</div>
</div>
<a class="anchor" id="gaa690c507e07624bd1cb15efd55fd66ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* tr_strratio </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>infinity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer to write the string to </td></tr>
    <tr><td class="paramname">buflef</td><td>buf's size </td></tr>
    <tr><td class="paramname">ratio</td><td>the ratio to convert to a string </td></tr>
    <tr><td class="paramname">the</td><td>string represntation of "infinity" </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadc192fcee2b2eaef436570655f853e68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* tr_strstrip </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>strips leading and trailing whitspace from a string </p>
<dl class="section return"><dt>Returns</dt><dd>the stripped string </dd></dl>

</div>
</div>
<a class="anchor" id="ga110e86ad5b0d95dd027b86dcda5f9240"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tr_timerAdd </td>
          <td>(</td>
          <td class="paramtype">struct event *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>microseconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience wrapper around timer_add () to have a timer wake up in a number of seconds and microseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td></td></tr>
    <tr><td class="paramname">seconds</td><td></td></tr>
    <tr><td class="paramname">microseconds</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaa8f64c97f0adff6a330abca6d07a789"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tr_timerAddMsec </td>
          <td>(</td>
          <td class="paramtype">struct event *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>milliseconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience wrapper around timer_add () to have a timer wake up in a number of milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td></td></tr>
    <tr><td class="paramname">milliseconds</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5dc03c76ccb0c5cb5e5e55c48d00320b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tr_truncd </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>decimal_places</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>truncate a double value at a given number of decimal places. </p>
<p>this can be used to prevent a printf () call from rounding up: call with the decimal_places argument equal to the number of decimal places in the printf ()'s precision:</p>
<ul>
<li>printf ("%.2f%%", 99.999 ) ==&gt; "100.00%"</li>
<li>printf ("%.2f%%", tr_truncd (99.999, 2)) ==&gt; "99.99%" ^ ^ | These should match | +---------------------&mdash;+ </li>
</ul>

</div>
</div>
<a class="anchor" id="ga9185d3bd416d17283e91f136d1a0a216"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tr_urlParse </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>url_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>setme_scheme</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>setme_host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>setme_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>setme_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parse a URL into its component parts </p>
<dl class="section return"><dt>Returns</dt><dd>zero on success or an error number if an error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="ga7fb641ec85cdeb5a7f6bc209d839b281"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* tr_utf8clean </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make a copy of 'str' whose non-utf8 content has been corrected or stripped </p>
<dl class="section return"><dt>Returns</dt><dd>a newly-allocated string that must be freed with tr_free () </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to make a clean copy of </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string to copy. If -1, the entire string is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga15cc1c8c721d921dde41b2da3331e1c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tr_wildmat </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rich Salz's classic implementation of shell-style pattern matching for ?, \, [], and * characters. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the pattern matches, 0 if it doesn't, or -1 if an error occured </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 27 2014 08:45:39 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
